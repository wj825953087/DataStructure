
# 字符串匹配算法
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们用的最多的就是编程语言提供的字符串查找函数，如Java中的indexOf（），Python中的find()函数等，底层都是依赖字符串匹配算法。

&nbsp;&nbsp; &nbsp; &nbsp;先定义两概念：**主串**、**模式串** ，主串长度记作n，模式串长度记作m。


1.  ## BF 算法  ——(暴力)朴素匹配算法


BF 思想简单概括:  在主串中，**检查起始位置**分别为0、1、2... n-m   且长度为m的n-m+1 个子串 ， 看有没有跟**模式串匹配**的 
  

3.  ## BM算法
&nbsp;&nbsp;我们把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF和RK算法的做法是，模式串往后滑动一位，然和从模式串的第一个字符开始重新匹配。
  BM算法两个重要规则及匹配顺序：


   * 匹配顺序是从模式串末尾开始匹配 

   * 坏字符规则  (没有匹配的字符就叫作坏字符)
              
            模式串后移的位数=模式串个数-每个坏字符串在模式串出现个数-末尾匹配成功个数(值到匹配到坏字符)

 ![img](https://github.com/wj825953087/DataStructure/blob/master/jpg/BM%E7%AE%97%E6%B3%95_1.jpg)
            


   * 好后缀规则
     &nbsp;&nbsp; &nbsp;&nbsp;将好后缀记作{A}，将模式串中与{A}匹配的记作{*A}，

   步骤：
   &nbsp;&nbsp; &nbsp;&nbsp;第一步： 在主串中找到好后缀；

  &nbsp;&nbsp;&nbsp;&nbsp;第二步：   拿好后缀{A}在模式串中查找，
   &nbsp;&nbsp;&nbsp;&nbsp;第三步：如果找到了另一个跟{A}相匹配的子串，那我们将模式串滑动到{*A}与主串中的{A}对齐的位置。
  &nbsp;&nbsp; &nbsp;&nbsp;第四步： 如果在模式串中找不到另一个等于{A}的子串，且模式串前缀子串没有与好后缀子串重合的部分，就直接将模式串，滑动到好后缀{A}的后面。
  &nbsp;&nbsp;&nbsp;&nbsp; 第五步：若模式串的前缀子串与好后缀的后缀字符串重合，我们从好后缀的后缀字符串中，找最长的并且能跟模式串的前缀字符串匹配的，将模式串滑动到该位置
   &nbsp;&nbsp; &nbsp;&nbsp; 字符串的后缀字符串：就是子串是跟最后一个字符对齐的字符串。例如：
  ！[img](https://)
    &nbsp;&nbsp; &nbsp;&nbsp;字符串的前缀字符串：就是子串是跟第一个字符对齐的字符串。例如：
    ！[img](https://)
            
 
